defmodule Teller.Accounts do
  @moduledoc """
    This module consists of functions that generate accounts data from token or account_id
  """
  alias Teller.Factory
  alias Teller.Helpers
  alias Teller.Schemas.{Account, AccountDetails, AccountBalances, Institution, Link, Routing}

  @doc """
    Generates account data using token. Each token will be able to access two accounts.
    Example using test_456789012321, the accounts with numbers 456789012321 and 456789012322
    will be generated.
  """
  def get_accounts(token) do
    [String.split(token, "_")]
    |> Enum.reduce(nil, fn [_, acc_no_start], _acc ->
      String.to_integer(acc_no_start)..(String.to_integer(acc_no_start) + 1)
    end)
    |> Enum.map(fn x ->
      get_account("acc_#{x}")
    end)
  end

  @doc """
    Generates account data using account_id.
    The acount is is hashed using phash2/2 to get an integer which will be used to get the
    values of institution and account_name. Hashing ensures that we get the same data for the account id each time.
  """
  def get_account(account_id) do
    hashed_account_id = :erlang.phash2(account_id)
    institution_length = Enum.count(Factory.institutions())
    names = Factory.account_names()
    names_length = Enum.count(Factory.account_names())
    last_four = String.slice(account_id, 12..-1)

    %Account{
      currency: "USD",
      enrollment_id: "enr_#{Base.encode64(account_id)}",
      id: account_id,
      institution: %Institution{
        id:
          "#{Recase.to_snake(Enum.at(Factory.institutions(), rem(hashed_account_id, institution_length)))}",
        name: Enum.at(Factory.institutions(), rem(hashed_account_id, institution_length))
      },
      last_four: last_four,
      links: %Link{
        balances: "#{TellerWeb.Endpoint.url()}/accounts/#{account_id}/balances",
        details: "#{TellerWeb.Endpoint.url()}/accounts/#{account_id}/details",
        self: "#{TellerWeb.Endpoint.url()}/accounts/#{account_id}",
        transactions: "#{TellerWeb.Endpoint.url()}/accounts/#{account_id}/transactions"
      },
      routing_numbers: %Routing{
        ach: account_id |> :erlang.phash2() |> :erlang.phash2()
      },
      name: Enum.at(names, rem(hashed_account_id, names_length)),
      subtype: "checking",
      type: "depository"
    }
  end

  @doc """
    Generates account details like account details like number and routing numbers
  """
  def get_account_details(account_id) do
    links = %Link{
      account: "#{TellerWeb.Endpoint.url()}/accounts/#{account_id}",
      self: "#{TellerWeb.Endpoint.url()}/accounts/#{account_id}/details"
    }

    account_number = String.trim_leading(account_id, "acc_")

    routing_numbers = %Routing{
      ach: account_id |> :erlang.phash2() |> :erlang.phash2() |> to_string()
    }

    %AccountDetails{
      account_id: account_id,
      account_number: account_number,
      links: links,
      routing_numbers: routing_numbers
    }
  end

  @doc """
    Generates account balance data. The initial balance of an account_id is generated by hashing the account_id using
    phash2/1 to get an integer. This is done so that we get the same starting balance each and every time for an account_id
    while also maintaining sufficient randomness between different accounts.
  """
  def get_account_balances(account_id) do
    links = %Link{
      account: "#{TellerWeb.Endpoint.url()}/accounts/#{account_id}",
      self: "#{TellerWeb.Endpoint.url()}/accounts/#{account_id}/balances"
    }

    opening_balance = Decimal.new(:erlang.phash2(account_id))
    salt = Decimal.new(Helpers.get_salt(account_id))
    {_, available} = Helpers.calculate_date_amounts(Decimal.new(opening_balance), salt)

    %AccountBalances{
      available: available,
      ledger: available,
      links: links,
      account_id: account_id
    }
  end
end
